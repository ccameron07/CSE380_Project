#include <vector>
#include "./eigen3/Eigen/Dense"

using namespace Eigen ;
using namespace std ;

class Node {
    public:
        int n, df ;
        bool boundary ;
        double BC ;
        Node(int n_init, int df_init = 0, bool boundary_init = false, double BC_init = 0.0);
}


Node::Node(int n_init, int df_init = 0, bool boundary_init = false, double BC_init = 0.0) {
    n = n_init ;
    df = df_init ;
    boundary = boundary_init;
    BC = BC_init ;
}
/*
class Node1d : Node {
    public:
        double coords;
        //Constructor Method
        Node1d(int n_init, double x, int df_init = 0, bool boundary_init = false, double BC_init = 0.0) {
            n = n_init ;
            df = df_init ;
            boundary = boundary_init;
            BC = BC_init
            coords = x ;
        }
 }

class Node2d : Node {
    public:
        Vector2d coords ;
        //Constructor Method
        Node2d(int n_init, double x, double y, int df_init = 0, bool boundary_init = false, double BC_init = 0.0) {
            n = n_init ;
            df = df_init ;
            boundary = boundary_init;
            BC = BC_init
            coords(0) = x ;
            coords(1) = y ;
        }
}

class Line {
    public:
        vector<Node*> nodes;
        
        Line(Node& n1, Node& n2) {
            nodes.push_back(n1);
            nodes.push_back(n2);
        }

        void addNodes(int n, vector<Node>& nodes_g, vector<Node*>& nodes_e) {
            vector<Node*>::reverse_iterator rit = nodes.rbegin() ;
            if (nodes.size() = (2+n)) {
                for(int i = 0; i<n; i++){
                    nodes_e.push_back(iter+i) ;
                }    
            } else {
                n_nodes = nodes_g.size() ;
                for(i = 0; i < n; i++){
                    nodes_g.push_back(Node temp(n_nodes+i, 0, (*nodes[0]).boundary, (*nodes[0]).BC)) ;
                    nodes_e.pushback(&Node[n_nodes]) ;
                    nodes.pushback(&Node[n_nodes]) ;
                }
            }
        }
}*/
